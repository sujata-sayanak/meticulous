{"mappings":"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","sources":["packages/recorder-loader/src/index.ts","packages/recorder-loader/src/loader.ts","packages/recorder-loader/src/constants.ts","packages/recorder-loader/src/install-meticulous-intercepts.ts"],"sourcesContent":["export { loadAndStartRecorder, tryLoadAndStartRecorder } from \"./loader\";\nexport { tryInstallMeticulousIntercepts } from \"./install-meticulous-intercepts\";\n","import { SNIPPETS_BASE_URL } from \"./constants\";\nimport { LoaderOptions } from \"./loader.types\";\n\nconst DEFAULT_MAX_MS_TO_BLOCK_FOR = 2_000;\n\n/**\n * Load and start the Meticulous Recorder\n */\nexport const tryLoadAndStartRecorder = async (\n  options: LoaderOptions\n): Promise<void> => {\n  // Try to load the recorder and silence any initialisation error.\n  await unsafeLoadAndStartRecorder(options).catch((error) => {\n    console.error(error);\n  });\n};\n\nconst unsafeLoadAndStartRecorder = ({\n  projectId,\n  uploadIntervalMs,\n  snapshotLinkedStylesheets,\n  commitHash,\n  maxMsToBlockFor: maxMsToBlockFor_,\n  snippetsBaseUrl,\n  forceRecording,\n  responseSanitizers,\n  isProduction,\n}: LoaderOptions): Promise<void> => {\n  let abandoned = false;\n\n  return new Promise<void>((resolve, reject) => {\n    const maxMsToBlockFor = maxMsToBlockFor_ ?? DEFAULT_MAX_MS_TO_BLOCK_FOR;\n\n    if (maxMsToBlockFor > 0) {\n      setTimeout(() => {\n        abandoned = true;\n        resolve();\n      }, maxMsToBlockFor);\n    }\n\n    const script = document.createElement(\"script\");\n    script.type = \"text/javascript\";\n    const baseSnippetsUrl = snippetsBaseUrl || SNIPPETS_BASE_URL;\n    script.src = new URL(\"v1/meticulous-manual-init.js\", baseSnippetsUrl).href;\n\n    // Setup configuration\n    const typedWindow = window;\n    typedWindow.METICULOUS_RECORDING_TOKEN = projectId;\n\n    if (uploadIntervalMs !== undefined) {\n      typedWindow.METICULOUS_UPLOAD_INTERVAL_MS = uploadIntervalMs;\n    }\n\n    if (commitHash !== undefined) {\n      typedWindow.METICULOUS_APP_COMMIT_HASH = commitHash;\n    }\n\n    if (snapshotLinkedStylesheets !== undefined) {\n      typedWindow.METICULOUS_SNAPSHOT_LINKED_STYLESHEETS =\n        snapshotLinkedStylesheets;\n    }\n\n    if (forceRecording !== undefined) {\n      typedWindow.METICULOUS_FORCE_RECORDING = forceRecording;\n    }\n\n    if (isProduction !== undefined) {\n      typedWindow.METICULOUS_IS_PRODUCTION_ENVIRONMENT = isProduction;\n    }\n\n    if (responseSanitizers != null && responseSanitizers.length > 0) {\n      typedWindow.METICULOUS_NETWORK_RESPONSE_SANITIZERS = responseSanitizers;\n    }\n\n    script.onload = function () {\n      if (abandoned) {\n        console.debug(\n          \"Meticulous snippet abandoned due to max blocking time reached.\"\n        );\n        // At this point the promise has already resolved.\n        return;\n      }\n\n      const initialiseRecorder = window.__meticulous?.initialiseRecorder;\n      if (typeof initialiseRecorder !== \"function\") {\n        reject(\"Meticulous recorder failed to initialise.\");\n        return;\n      }\n\n      try {\n        initialiseRecorder();\n      } catch (error) {\n        reject(error);\n      }\n\n      resolve();\n    };\n    script.onerror = () => {\n      reject(\"Meticulous recorder failed to initialise.\");\n    };\n\n    document.head.appendChild(script);\n  });\n};\n\n/**\n * @deprecated Use `tryLoadAndStartRecorder` instead.\n *\n * Load and start the Meticulous Recorder\n */\nexport const loadAndStartRecorder = unsafeLoadAndStartRecorder;\n","export const SNIPPETS_BASE_URL = \"https://snippet.meticulous.ai\";\n","import { SNIPPETS_BASE_URL } from \"./constants\";\nimport { tryLoadAndStartRecorder } from \"./loader\";\nimport { LoaderOptions } from \"./loader.types\";\n\ninterface EarlyNetworkRecorderWindow {\n  __meticulous?: {\n    earlyNetworkRecorder?: {\n      dispose?: () => Promise<void>;\n    };\n  };\n}\n\nexport interface Interceptor {\n  startRecordingSession: (options: LoaderOptions) => Promise<void>;\n  stopIntercepting: () => Promise<void>;\n}\n\n/**\n * Stores a copy of network requests and responses in memory, but doesn't send them to the\n * server, until the the main recorder is initialised.\n *\n * This is useful if you only want to record sessions for certain users with certain attributes. In\n * this case you have an issue: you need to wait for the user information to load before you know whether\n * you can enable the recorder, but if you enable the recorder after the user information has loaded\n * then the recorder won't be able to capture the initial request & response to load the user information,\n * or other early network responses.\n *\n * The early network recorder solves this: load the early network recorder for all sessions,\n * but only load the main recorder for sessions that you want to record. If when you load the user data\n * you find out you don't want to record the session then you can call the stopRecording() method returned\n * by this method.\n *\n * Example usage:\n *\n * ```\n * // The below call should happen before your app makes any network requests,\n * // or executes any methods that may store a reference to window.fetch or XMLHttpRequest.\n * const interceptor = await tryInstallMeticulousIntercepts();\n *\n * // Later, when you have loaded user data...\n * const userData = await loadUserInfo();\n * if (shouldRecord(userData)) {\n *  await interceptor.startRecordingSession({ ... });\n * } else {\n *  interceptor.stopIntercepting();\n * }\n * ```\n */\nexport const tryInstallMeticulousIntercepts = async (\n  options: { maxMsToBlockFor: number } = { maxMsToBlockFor: 2000 }\n): Promise<Interceptor> => {\n  let requestedToStopIntercepting = false;\n  let disposedEarlyNetworkRecorder = false;\n  const stopIntercepting = async () => {\n    requestedToStopIntercepting = true;\n    const disposeFunction = (window as EarlyNetworkRecorderWindow)?.__meticulous\n      ?.earlyNetworkRecorder?.dispose;\n    if (disposeFunction && !disposedEarlyNetworkRecorder) {\n      await disposeFunction();\n      disposedEarlyNetworkRecorder = true;\n    }\n  };\n  const startRecordingSession = tryLoadAndStartRecorder;\n  const interceptor = { startRecordingSession, stopIntercepting };\n\n  const promise = new Promise<Interceptor>((resolve, reject) => {\n    const timeout =\n      options.maxMsToBlockFor > 0\n        ? setTimeout(() => {\n            resolve(interceptor);\n          }, options.maxMsToBlockFor)\n        : null;\n\n    const script = document.createElement(\"script\");\n    script.type = \"text/javascript\";\n    script.src = `${SNIPPETS_BASE_URL}/record/v1/network-recorder.bundle.js`;\n\n    script.onload = function () {\n      if (timeout) {\n        window.clearTimeout(timeout);\n      }\n      resolve(interceptor);\n    };\n    script.onerror = () => {\n      if (timeout) {\n        window.clearTimeout(timeout);\n      }\n      reject(\"Meticulous early network recorder failed to initialise.\");\n    };\n\n    document.head.appendChild(script);\n  });\n\n  // Try to load the early network recorder and silence any initialisation error.\n  return promise\n    .catch((error) => {\n      console.error(error);\n      return interceptor;\n    })\n    .finally(() => {\n      if (requestedToStopIntercepting) {\n        stopIntercepting();\n      }\n    });\n};\n"],"names":[],"version":3,"file":"index.js.map"}